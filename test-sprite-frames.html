<!DOCTYPE html>
<html>
<head>
    <title>Debug Sprite Frame Clipping</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: monospace;
        }
        .info {
            background: rgba(255,0,255,0.2);
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #ff00ff;
        }
    </style>
</head>
<body>
    <h1>üîç Debugging Sprite Clipping Issue</h1>
    <div class="info">
        Testing different origin points and display methods to fix clipping
    </div>
    <div id="game"></div>

    <script>
    class TestScene extends Phaser.Scene {
        preload() {
            // Try loading with different frame dimensions to see if that's the issue
            this.load.spritesheet('test1', 'assets/sprites/stinkylee.png', {
                frameWidth: 32,
                frameHeight: 30
            });
            
            // Also try loading as regular image to inspect
            this.load.image('fullsheet', 'assets/sprites/stinkylee.png');
        }
        
        create() {
            this.cameras.main.setBackgroundColor('#2d2d2d');
            
            // Show the full sprite sheet first
            const fullSheet = this.add.image(100, 300, 'fullsheet');
            fullSheet.setScale(0.5);
            fullSheet.setOrigin(0, 0.5);
            
            // Add label
            this.add.text(100, 450, 'Full Sprite Sheet (0.5x)', {
                fontSize: '12px',
                color: '#0ff'
            }).setOrigin(0, 0);
            
            // Test different approaches for row 4 (walk up)
            const row = 4;
            const startFrame = row * 32; // Frame 128
            
            // Approach 1: Normal sprite with default origin
            const sprite1 = this.add.sprite(650, 100, 'test1', startFrame);
            sprite1.setScale(4);
            this.add.text(650, 180, 'Default Origin (0.5, 0.5)', {
                fontSize: '12px',
                color: '#ff0'
            }).setOrigin(0.5, 0);
            
            // Create animation
            this.anims.create({
                key: 'test_walk',
                frames: this.anims.generateFrameNumbers('test1', {
                    start: startFrame,
                    end: startFrame + 7
                }),
                frameRate: 8,
                repeat: -1
            });
            sprite1.play('test_walk');
            
            // Approach 2: Sprite with adjusted origin
            const sprite2 = this.add.sprite(650, 300, 'test1', startFrame);
            sprite2.setScale(4);
            sprite2.setOrigin(0.5, 1); // Bottom center origin
            sprite2.play('test_walk');
            this.add.text(650, 380, 'Bottom Origin (0.5, 1)', {
                fontSize: '12px',
                color: '#ff0'
            }).setOrigin(0.5, 0);
            
            // Approach 3: Sprite with top origin
            const sprite3 = this.add.sprite(650, 500, 'test1', startFrame);
            sprite3.setScale(4);
            sprite3.setOrigin(0.5, 0); // Top center origin
            sprite3.play('test_walk');
            this.add.text(650, 580, 'Top Origin (0.5, 0)', {
                fontSize: '12px',
                color: '#ff0'
            }).setOrigin(0.5, 0);
            
            // Draw debug rectangles to show sprite bounds
            const graphics = this.add.graphics();
            graphics.lineStyle(2, 0xff00ff, 0.5);
            
            // For sprite1
            const bounds1 = sprite1.getBounds();
            graphics.strokeRect(bounds1.x, bounds1.y, bounds1.width, bounds1.height);
            
            // Get frame info
            if (this.textures.exists('test1')) {
                const texture = this.textures.get('test1');
                const frame = texture.get(startFrame);
                console.log('Frame info for row 4:', {
                    frameIndex: startFrame,
                    width: frame.width,
                    height: frame.height,
                    cutX: frame.cutX,
                    cutY: frame.cutY,
                    cutWidth: frame.cutWidth,
                    cutHeight: frame.cutHeight,
                    sourceSize: {
                        w: texture.source[0].width,
                        h: texture.source[0].height
                    }
                });
                
                // Display frame info
                this.add.text(20, 20, [
                    'Frame Debug Info (Row 4, Frame 128):',
                    `Frame size: ${frame.width} x ${frame.height}`,
                    `Cut position: (${frame.cutX}, ${frame.cutY})`,
                    `Cut size: ${frame.cutWidth} x ${frame.cutHeight}`,
                    `Sprite sheet: ${texture.source[0].width} x ${texture.source[0].height}`
                ].join('\n'), {
                    fontSize: '14px',
                    color: '#0f0',
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    padding: { x: 10, y: 10 }
                });
            }
            
            // Test manual frame extraction
            this.time.delayedCall(1000, () => {
                // Try different frames in row 4
                console.log('Testing frames in row 4:');
                for (let i = 0; i < 8; i++) {
                    const frameIdx = startFrame + i;
                    const frame = this.textures.get('test1').get(frameIdx);
                    if (frame) {
                        console.log(`Frame ${frameIdx}:`, {
                            exists: true,
                            y: frame.cutY,
                            height: frame.height
                        });
                    }
                }
            });
        }
    }
    
    const game = new Phaser.Game({
        type: Phaser.AUTO,
        width: 900,
        height: 700,
        parent: 'game',
        backgroundColor: '#2d2d2d',
        pixelArt: true,
        scene: TestScene
    });
    </script>
</body>
</html>